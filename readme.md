# Understanding map and apply
## https://fsharpforfunandprofit.com/posts/elevated-world/#series-toc

### The Elevated World
We can imagine that there are two worlds in which we can program--a "normal" everyday world, as well as an "elevated" world. Every thing in the normal world has a corresponding thing in the elevated world. There are too many different kinds of elevated worlds with nothing in common to exactly define the concept--they may represent data structures (`Option<T>`), workflows (`State<T>`), signals (`Observable<T>`), asynchronous values (`Async<T>`), or other concepts.

However, even though the elevated worlds have nothing in common specifically, there are commonalities in the ways with which they can be worked--there are certain isues that often occur in different elevated worlds that can be dealt with using standard tools and patterns. 

Some assumptions:
1. Every type in the normal world has a corresponding type in the elevated world
2. Every value in the normal world has a corresponding value in the elevated world
3. Every function in the normal world has a corresponding value in the elevated world

### 1. Lifting to the elevated world
The concept of moving something from the normal world to the elevated world is called **lifting**, and thus when lifted, normal-world things could also be called **lifted values**, **lifted types**, and **lifted functions**. Because each elevated world is different there is no common implementation for lifting, but we can give names the various patterns used (EG. `map`, `return`).

#### 1.1 `map`
**Common names:** `map`, `fmap`, `lift`, `select` <br>
**Common operators:** `<$>`, `<!>` <br>
**Purpose:** Lift a function into the elevated wold <br>
**Signature:** `( a -> b ) -> E<a> -> E<b>` (or, with parameters reversed: `E<a> -> ( a -> b ) -> E<b>`)

`map` is a generic name for something that takes a function in the normal world and transforms it into a corresponding function in the elevated world:
```fsharp
( a -> b ) -> E<a> -> E<b>
``` 

We can also interpret `map` as a two-parameter function that takes an elevated value `E<a>` and a normal function `( a -> b )` and returns a new elevated value `E<b>` generated by applying the function `a -> b` to the internal elements of `E<a>`. In languages where functions are curried by default, these two interpretations are the same. Note that the function signature of the two-parameter version often has the paramters reversed, EG. `E<a> -> ( a -> b ) -> E<b>`.

Implementation example for `Option`:
```fsharp
/// ( 'a -> 'b ) -> 'a option -> 'b option
let mapOption fn opt =
    match opt with
    | None   -> None
    | Some x -> Some ( fn x )
```

Implementation example for `List`:
```fsharp
/// ( 'a -> 'b ) -> 'a list -> 'b list
let rec mapList fn list =
    match list with
    | [] -> []
    | head::tail ->
        // New head + new tail
        ( fn head ) :: ( mapList fn tail )
```

In F# these functions are already built-in, but they do provide good examples. Example usage:
```fsharp
// Normal-world function
let add1 x = x + 1

// Function lifted to Option
let add1IfSomething = Option.map add1

// Function lifted to List
let add1ToEachElement = List.map add1

Some 2 |> add1IfSomething // Some 3
[ 1; 2; 3 ] |> add1ToEachElement // [ 2; 3; 4; ]
``` 

We don't strictly need to bother with the intermediate functions--we can use partial application instead:
```fsharp
Some 2 |> Option.map add1 // Some 3
[ 1; 2; 3; ] |> List.map add1 // [ 2; 3; 4; ]
```

There are two properties that the implementation should satisfy to avoid strange behaviour:
1. If we lift a function `fn` into the elevated world using `map`, the new function must be the same as the function `fn` in the elevated world
2. If we take the two functions `fnA` and `fnB` in the normal world, compose them into `fnC` and then lift this function into the elevated world using `map`, the resulting function should be the same as if we lifted `fnA` and `fnB` into the elevated world _first_ and then composed them there afterwards

These two properies are the so-called [Functor Laws](https://en.wikibooks.org/wiki/Haskell/The_Functor_class#The_functor_laws). In the programming sense, a functor is defined as a generic data type with a `map` function that obeys these laws.

### 1.2 `return`
**Common names:** `return`, `pure`, `unit`, `yield`, `point` <br>
**Common operators:** None <br>
**What it does:** Lifts a single value into the elevated world <br>
**Signature:** `a -> E<a>` <br>

`return` creates an elevated value from a normal value.

Implementation examples:
```fsharp
// 'a -> 'a option
let returnOpt x = Some x 

// 'a -> 'a list
let returnList x = [ x ]
```

### 1.3 `apply` 
**Common names:** `apply`, `ap` <br>
**Common operators:** `<*>` <br>
**What it does:** Unpacks a function wrapped inside an elevated value into a lifted function <br>
**Signature:** `E<( a -> b )> -> E<a> -> E<b>` <br>

`apply` unpacks a function wrapped inside an elevated value into a lifted function. This allows us to lift a normal-world multi-parameter function into an elevated-world multi-parameter function.

An alternative interpretation of `apply` is that it is a two-parameter function that takes an elevated value `E<a>` and an elevated function `E<( a -> b )>` and returns a new elevated value `E<b>` that is generated by applying the function `( a -> b )` to the internal elements of `E<a>`. 

For example:
- Given the one-parameter function `E<( a -> b )>`, we can `apply` it to the single elevated value `E<a>` to get the elevated output `E<b>`
- Given the two-parameter function `E<( a -> b -> c )>`, we can use `apply` twice in succession with the two elevated parameters `E<a>` and `E<b>` to get the elevated output `E<c>` 

Example implementations:
```fsharp
module Option =

    let apply fOpt xOpt =
        match fOpt, xOpt with
            | Some f, Some x -> Some ( f x )
            | _              -> None

module List =

    // [ f; g ] apply [ x; y ] becomes [ f x; f y; g x; g y ]
    let apply ( fList: ( 'a -> 'b ) list ) ( xList: 'a list ) =
        [ for f in fList do
          for x in xList do
            yield f x ]
```

It's common to create an infix version of `apply`, typically `<*>`:
```fsharp
let resultOption =
    let ( <*> ) = Option.apply

    ( Some add ) <*> ( Some 2 ) <*> ( Some 3 ) // Some 5

let resultList =
    let ( <*> ) = List.apply

    [ add ] <*> [ 1; 2 ] <*> [ 10; 20 ] // [ 11; 21; 12; 22 ]
```
#### `apply` vs. `map`
The combination of `apply` and `return` is considered more "powerful" than `map`, because if we have the two former then we can construct from them `map`, but not vice versa. 

To create a lifted function from a normal function, just use `return` on the normal function and then `apply`. This gives the same result as just using `map`.